--
-- Migration: V1__init_schema.sql
-- Purpose: Initialize the database schema for the YourList application.
-- Tables created: users, shopping_lists, items, shopping_list_shares
--
-- This migration sets up the core tables required for the application to function,
-- including user management, shopping lists, and item tracking. It also establishes
-- relationships between these tables and creates indexes for performance optimization.
--

-- =============================================================================
-- TABLE: users
-- =============================================================================
-- STEP 1: Create the "users" table.
-- This table stores information about registered users, including their credentials.
CREATE TABLE users (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    email VARCHAR(255) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

-- Add a comment to the "users" table for clarity.
COMMENT ON TABLE users IS 'Stores information about registered users.';


-- =============================================================================
-- TABLE: shopping_lists
-- =============================================================================
-- STEP 2: Create the "shopping_lists" table.
-- This table stores shopping lists created by users.
CREATE TABLE shopping_lists (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    owner_id BIGINT NOT NULL,
    name VARCHAR(255) NOT NULL,
    share_token UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    CONSTRAINT fk_shopping_lists_owner_id FOREIGN KEY (owner_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Add a comment to the "shopping_lists" table.
COMMENT ON TABLE shopping_lists IS 'Stores shopping lists created by users.';


-- =============================================================================
-- TABLE: items
-- =============================================================================
-- STEP 3: Create the "items" table.
-- This table stores individual items within a shopping list.
CREATE TABLE items (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    shopping_list_id BIGINT NOT NULL,
    name VARCHAR(255) NOT NULL,
    description VARCHAR(255),
    is_bought BOOLEAN NOT NULL DEFAULT false,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    CONSTRAINT fk_items_shopping_list_id FOREIGN KEY (shopping_list_id) REFERENCES shopping_lists(id) ON DELETE CASCADE
);

-- Add a comment to the "items" table.
COMMENT ON TABLE items IS 'Stores individual items on shopping lists.';


-- =============================================================================
-- TABLE: shopping_list_shares
-- =============================================================================
-- STEP 4: Create the "shopping_list_shares" table.
-- This is a join table to manage user access to shared lists.
CREATE TABLE shopping_list_shares (
    shopping_list_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,
    PRIMARY KEY (shopping_list_id, user_id),
    CONSTRAINT fk_shopping_list_shares_shopping_list_id FOREIGN KEY (shopping_list_id) REFERENCES shopping_lists(id) ON DELETE CASCADE,
    CONSTRAINT fk_shopping_list_shares_user_id FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Add a comment to the "shopping_list_shares" table.
COMMENT ON TABLE shopping_list_shares IS 'Manages access for users to shared lists.';


-- =============================================================================
-- INDEXES
-- =============================================================================
-- STEP 5: Create indexes to optimize query performance.
-- Indexes are created on foreign keys and frequently queried columns.
CREATE INDEX idx_shopping_lists_owner_id ON shopping_lists(owner_id);
CREATE INDEX idx_items_shopping_list_id ON items(shopping_list_id);
CREATE INDEX idx_shopping_list_shares_shopping_list_id ON shopping_list_shares(shopping_list_id);
CREATE INDEX idx_shopping_list_shares_user_id ON shopping_list_shares(user_id);
-- Unique indexes are already created by UNIQUE constraints on users(email) and shopping_lists(share_token).


-- =============================================================================
-- TRIGGERS AND FUNCTIONS
-- =============================================================================
-- STEP 6: Create a function and trigger to update the "updated_at" timestamp on the "shopping_lists" table.
-- This ensures that the "updated_at" field is current whenever an item is added, updated, or deleted.

-- Define the function that updates the timestamp.
CREATE OR REPLACE FUNCTION update_shopping_list_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    -- Update the updated_at timestamp of the parent list.
    -- This handles INSERT, UPDATE, and DELETE operations on the items table.
    UPDATE shopping_lists
    SET updated_at = NOW()
    WHERE id = COALESCE(NEW.shopping_list_id, OLD.shopping_list_id);
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- Add a comment to the function.
COMMENT ON FUNCTION update_shopping_list_updated_at() IS 'Function to update the updated_at timestamp on the shopping_lists table when an item changes.';

-- Create the trigger that executes the function after an item is changed.
CREATE TRIGGER trigger_update_shopping_list_on_item_change
AFTER INSERT OR UPDATE OR DELETE ON items
FOR EACH ROW
EXECUTE FUNCTION update_shopping_list_updated_at();

-- Add a comment to the trigger.
COMMENT ON TRIGGER trigger_update_shopping_list_on_item_change ON items IS 'Updates the list timestamp when an item is inserted, updated, or deleted.';
